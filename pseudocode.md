# Accessed homework

Алгоритм выбора порядковой статистики (k-го по порядку элемента) из неотсортированного массива.  
Реализован с помощью случайного выбора опорного элемента и трёхстороннего разбиения.

---

## Требования к типу элементов

Все элементы массива должны быть **сравнимыми**, то есть поддерживать операции:
- `<` — строгое сравнение,
- `==` — проверка на равенство.

---

## Функция `split`

**Назначение:**  
Реорганизует массив на месте, разделяя его на три части:
- элементы `< p`,
- элементы `== p`,
- элементы `> p`.

**Вход:**
- `arr`: массив элементов (`arr[0..n-1]`), допускающих сравнение,
- `p`: опорный элемент.

**Выход:**
- `(low, high)` — границы отрезка элементов, равных `p`:  
  - `arr[0..low-1] < p`,  
  - `arr[low..high] == p`,  
  - `arr[high+1..n-1] > p`.
- `nullopt`, если массив пуст.

**Побочный эффект:**
- Изменяет (переставляет) элементы массива `arr`.

```pseudocode
ФУНКЦИЯ SPLIT(arr, p):
    ЕСЛИ arr пуст:
        ВЕРНУТЬ null

    low ← 0
    mid ← 0
    high ← ДЛИНА(arr) - 1

    ПОКА mid ≤ high:
        ЕСЛИ arr[mid] < p:
            Поменять местами arr[low] и arr[mid]
            low ← low + 1
            mid ← mid + 1
        ИНАЧЕ ЕСЛИ arr[mid] == p:
            mid ← mid + 1
        ИНАЧЕ:  // arr[mid] > p
            Поменять местами arr[mid] и arr[high]
            high ← high - 1

    ВЕРНУТЬ (low, high)
```

---

## Функция `select`

**Назначение:**  
Находит **k-й порядковый статистический элемент** массива — то есть элемент, который оказался бы на позиции `k` после сортировки (по возрастанию).

**Вход:**
- `arr`: массив элементов (`arr[0..n-1]`), допускающих сравнение,
- `k`: индекс порядковой статистики, `0 ≤ k < arr.size()`

**Выход:**
- Элемент, который находится на позиции `k` в отсортированном массиве,
- `nullopt`, если массив пуст.

**Побочный эффект:**
- Модифицирует (переставляет) массив `arr`.

```pseudocode
ФУНКЦИЯ SELECT(arr, k):
    ЕСЛИ arr пуст:
        ВЕРНУТЬ null

    p ← СЛУЧАЙНЫЙ_ЭЛЕМЕНТ(arr)
    (low, high) ← SPLIT(arr, p)

    ЕСЛИ k < low:
        ВЕРНУТЬ SELECT(arr[0 : low], k)
    ИНАЧЕ ЕСЛИ k ≤ high:
        ВЕРНУТЬ p
    ИНАЧЕ:
        ВЕРНУТЬ SELECT(arr[high + 1 : n], k - high - 1)
```

---

## Примечания

- **Средняя сложность:** O(n)
- **Худший случай:** O(n²), при неудачном выборе опорных элементов (маловероятно)
- Метод используется для:
  - Нахождения медианы
  - Быстрого выбора top-k значений
  - Квартилей и других статистических метрик

---

## Пример использования

```cpp
std::vector<int> data = {9, 2, 7, 1, 4, 3, 6};
auto result = select(data, 3); // Найдёт элемент, который стоит на 4-й позиции по возрастанию (индекс 3), т.е. 4
```