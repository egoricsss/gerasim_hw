# Accessed homework

Алгоритм выбора порядковой статистики (k-го по порядку элемента) из неотсортированного массива.  
Реализован с помощью случайного выбора опорного элемента и трёхстороннего разбиения.

---

## Требования к типу элементов

Все элементы массива должны быть **сравнимыми**, то есть поддерживать операции:
- `<` — строгое сравнение,
- `==` — проверка на равенство.

---

## Функция `split`

**Назначение:**  
Реорганизует массив на месте, разделяя его на три части:
- элементы `< p`,
- элементы `== p`,
- элементы `> p`.

**Вход:**
- `arr`: массив элементов (`arr[0..n-1]`), допускающих сравнение,
- `p`: опорный элемент.

**Выход:**
- `(l, r)` — границы отрезка элементов, равных `p`:  
  - `arr[0..l-1] < p`,  
  - `arr[l..r] == p`,  
  - `arr[r+1..n-1] > p`.
- `nullopt`, если массив пуст.

**Побочный эффект:**
- Изменяет (переставляет) элементы массива `arr`, группируя элементы в заданном порядке.

```pseudocode
процедура split(arr[1..n], p)
// Вход: массив arr[1..n] из n ≥ 1 элементов, допускающих сравнение; опорный элемент p ∈ arr[1..n]
// Выход: пара индексов (l, r), таких что:
//        - arr[1 .. l−1] < p
//        - arr[l .. r] == p
//        - arr[r+1 .. n] > p
// Побочные эффекты: переставляет элементы массива arr на месте

    i ← 1

    // Первый проход: выносим все элементы < p в начало массива
    для j от 1 до n:
        если arr[j] < p:
            обмен arr[i] и arr[j]
            i ← i + 1

    l ← i

    // Второй проход: выносим все элементы == p после элементов < p
    для j от l до n:
        если a[j] == p:
            обмен arr[i] и arr[j]
            i ← i + 1

    r ← i − 1

    вернуть (l, r)
```

---

## Функция `select`

**Назначение:**  
Находит **k-й порядковый статистический элемент** массива — то есть элемент, который оказался бы на позиции `k` после сортировки (по возрастанию).

**Вход:**
- `arr`: массив элементов (`arr[0..n-1]`), допускающих сравнение,
- `k`: индекс порядковой статистики, `0 ≤ k < arr.size()`

**Выход:**
- Элемент, который находится на позиции `k` в отсортированном массиве,
- `nullopt`, если массив пуст.

**Побочный эффект:**
- Модифицирует (переставляет) массив `arr`.

```pseudocode
функция select(arr[1..n], k)
// Вход: массив arr[1..n] из n ≥ 1 элементов, допускающих сравнение; 
//       целое k ∈ 1..n — позиция порядковой статистики (по возрастанию)
// Выход: значение, стоящее в отсортированном массиве arr на позиции k
// Побочные эффекты: изменяет массив a (переставляет элементы)

    выбрать случайный индекс j из 1..n
    p ← arr[j]
    (l, r) ← split(arr, p)

    если k < l:
        вернуть select(arr[1 .. l−1], k)
    если k ≤ r:
        вернуть p
    иначе:
        вернуть select(arr[r+1 .. n], k − r)
```

---

## Примечания

- **Средняя сложность:** O(n)
- **Худший случай:** O(n²), при неудачном выборе опорных элементов (маловероятно)
- Метод используется для:
  - Нахождения медианы
  - Быстрого выбора top-k значений
  - Квартилей и других статистических метрик

---

## Пример использования

```cpp
std::vector<int> data = {9, 2, 7, 1, 4, 3, 6};
auto result = select(data, 3); // Найдёт элемент, который стоит на 4-й позиции по возрастанию (индекс 3), т.е. 4
```